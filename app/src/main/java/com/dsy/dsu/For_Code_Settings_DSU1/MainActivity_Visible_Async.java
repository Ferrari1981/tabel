package com.dsy.dsu.For_Code_Settings_DSU1;import android.Manifest;import android.app.Activity;import android.content.BroadcastReceiver;import android.content.ComponentName;import android.content.ContentValues;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.content.ServiceConnection;import android.content.SharedPreferences;import android.content.pm.ActivityInfo;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.content.res.ColorStateList;import android.database.sqlite.SQLiteCursor;import android.graphics.BlendMode;import android.graphics.Color;import android.graphics.PorterDuff;import android.graphics.drawable.Drawable;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.os.Environment;import android.os.Handler;import android.os.IBinder;import android.os.Looper;import android.os.Message;import android.os.Messenger;import android.os.VibrationEffect;import android.os.Vibrator;import android.util.Log;import android.view.Gravity;import android.view.MenuItem;import android.view.View;import android.view.WindowManager;import android.view.animation.Animation;import android.view.animation.AnimationUtils;import android.widget.Button;import android.widget.ImageView;import android.widget.ProgressBar;import android.widget.TextView;import android.widget.Toast;import androidx.annotation.NonNull;import androidx.annotation.UiThread;import androidx.appcompat.app.AlertDialog;import androidx.appcompat.app.AppCompatActivity;import androidx.constraintlayout.widget.ConstraintLayout;import androidx.core.app.ActivityCompat;import androidx.core.content.FileProvider;import androidx.drawerlayout.widget.DrawerLayout;import androidx.localbroadcastmanager.content.LocalBroadcastManager;import androidx.multidex.BuildConfig;import com.dsy.dsu.Business_logic_Only_Class.CREATE_DATABASE;import com.dsy.dsu.Business_logic_Only_Class.Class_Connections_Server;import com.dsy.dsu.Business_logic_Only_Class.Class_Find_Setting_User_Network;import com.dsy.dsu.Business_logic_Only_Class.Class_GRUD_SQL_Operations;import com.dsy.dsu.Business_logic_Only_Class.Class_Generation_Errors;import com.dsy.dsu.Business_logic_Only_Class.Class_MODEL_synchronized;import com.dsy.dsu.Business_logic_Only_Class.Class_Update_Download_File_APK_From_SERVER;import com.dsy.dsu.Business_logic_Only_Class.PUBLIC_CONTENT;import com.dsy.dsu.Code_For_Firebase_AndOneSignal_Здесь_КодДЛяСлужбыУведомленияFirebase.Class_Generation_SendBroadcastReceiver_And_Firebase_OneSignal;import com.dsy.dsu.Code_For_Services.Service_For_Public;import com.dsy.dsu.Code_For_Services.Service_For_Remote_Async;import com.dsy.dsu.R;import com.google.android.material.dialog.MaterialAlertDialogBuilder;import com.google.android.material.navigation.NavigationView;import java.io.File;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.Locale;import java.util.TimeZone;import java.util.concurrent.ExecutionException;public class MainActivity_Visible_Async extends AppCompatActivity  {    private   Date ДатаДляИзмененияВерсииДанныхНаАндройде;    private ProgressBar progressBar3ГоризонтальныйСинхронизации;    private  ProgressBar progressBarCycle;    private TextView ТекстВидBarСинх;    private TextView textViewТекущийПользовательПРиВизуальнойСинхронизации;    private Integer ПолученныйПубличныйID = 0;    private  Boolean  ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ=false;    private  CREATE_DATABASE Create_Database_СсылкаНАБазовыйКласс;    private  Activity activity;    private  String РежимПерваяЗапускПослеPasswordИлиПовторная = new String();    private   PUBLIC_CONTENT Class_Engine_SQLГдеНаходитьсяМенеджерПотоков = null;    private   Integer ПубличноеIDПолученныйИзСервлетаДляUUID = 0;    private DrawerLayout drawerLayoutAsync;    private NavigationView navigationViewAsyncApp;    private       ImageView imageView_ЗначекAsync;    private  ConstraintLayout constraintLayoutAsync;    private  TextView ТекущаяТаблицыИлиГод;    private Service_For_Remote_Async service_for_tabelAsync;    private Messenger messengerActivity;    private Messenger mMessenger;    private     ServiceConnection myConnection;    private Boolean ВостанновленоеСтатусЗапускаAsync=false;    private SharedPreferences preferences;    private Animation animation;    @Override    protected void onCreate(Bundle savedInstanceState) {        try{            super.onCreate(savedInstanceState);            setContentView(R.layout.activity_main__sinfrozisaziy__prograssbar);            МетодСитемныйНастройкиЭкран();            // TODO: 15.09.2021 ПРИШЕЛ ПАРАМЕНТ КАКУЮ НУЖНО ЗАПИСТИТЬ СИНХРОНИЗАЦИЮ           // preferences = PreferenceManager.getDefaultSharedPreferences(this);            preferences = getSharedPreferences("sharedPreferencesХранилище", Context.MODE_MULTI_PROCESS);            Intent     Интент_AsyncApp=getIntent();            Class_Engine_SQLГдеНаходитьсяМенеджерПотоков =new PUBLIC_CONTENT(getApplicationContext());            РежимПерваяЗапускПослеPasswordИлиПовторная = Интент_AsyncApp.getStringExtra("РежимЗапускаСинхронизации");            ///TODO принудительно устанвливаем редим работы синхронизации            Log.d(this.getClass().getName(), " КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная "+ РежимПерваяЗапускПослеPasswordИлиПовторная);            Create_Database_СсылкаНАБазовыйКласс=new CREATE_DATABASE(getApplicationContext());            ///TODO КОНТЕКСТ КОТОРЫЙ ПЕРЕДАЮТ ПО ВСЕЙ СИНХРОНИЗАЦИИИ НА ВСЕ ПРИЛОЖЕНИЕ            activity =this;            ((Activity) activity).setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);            ((Activity) activity) .setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);            /////todo данная настрока запрещает при запуке активти подскаваать клавиатуре вверх на компонеты eedittext            //////todo  конец настрока экран////todo запрещает поворот экрана            Log.d(this.getClass().getName(), "Сработал  protected void onCreate(Bundle savedInstanceState)  MainActivity_Visible_Async" );            getSupportActionBar().hide(); ///скрывать тул бар            progressBarCycle =(ProgressBar) findViewById(R.id.progressBar4ПоКругуСинхронизации); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            progressBar3ГоризонтальныйСинхронизации =(ProgressBar) findViewById(R.id.progressBar3ГоризонтальныйСинхронизации);            ТекстВидBarСинх=(TextView) findViewById(R.id.TextViewДляProgressBarГлавнойСинхронизации); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            textViewТекущийПользовательПРиВизуальнойСинхронизации=(TextView) findViewById(R.id.textViewТекущийПользовательПРиВизуальнойСинхронизации); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            navigationViewAsyncApp    = (NavigationView) findViewById(R.id.navigator_asyncapp); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            imageView_ЗначекAsync = (ImageView) findViewById(R.id.imageView_icon_asynsapp);            drawerLayoutAsync = (DrawerLayout) findViewById(R.id.drawerLayout_async_prograsser); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            constraintLayoutAsync    = (ConstraintLayout) findViewById(R.id.constraintLayout_asynsprograsser);            drawerLayoutAsync.setBackgroundColor(Color.WHITE);         //TODO устанвливает цвета            constraintLayoutAsync.setBackgroundColor(Color.WHITE);            drawerLayoutAsync.setBackgroundColor(Color.WHITE);            drawerLayoutAsync.setDrawingCacheBackgroundColor(Color.RED);//todo            ТекущаяТаблицыИлиГод = (TextView) findViewById(R.id.TExtViewНазваниеКонторыСнизуСинх); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            // animation = AnimationUtils.loadAnimation(getContext(), R.anim.slide_in_row_vibrator1);            animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.slide_in_row_vibrator1);            // TODO: 25.10.2022 востанавливаем данных после поворота экрана            if(savedInstanceState!=null){                ВостанновленоеСтатусЗапускаAsync = savedInstanceState.getBoolean("ВостанновленоеСтатусЗапускаAsync");                Log.d(this.getClass().getName(), "ВостанновленоеСтатусЗапускаAsync"+ ВостанновленоеСтатусЗапускаAsync);                ТекстВидBarСинх.setText(savedInstanceState.getString("ТекстВидBarСинх"));                ТекущаяТаблицыИлиГод.setText(savedInstanceState.getString("ТекущаяТаблицыИлиГод"));                progressBar3ГоризонтальныйСинхронизации.setProgress(savedInstanceState.getInt("progressBar3ГоризонтальныйСинхронизации"));                progressBar3ГоризонтальныйСинхронизации.setSecondaryProgress(savedInstanceState.getInt("progressBar3ГоризонтальныйСинхронизацииback"));                progressBarCycle.setProgress(savedInstanceState.getInt("progressBar4Cycle"));                progressBarCycle.setMax(savedInstanceState.getInt("progressBar4CycleMAx"));            }            // TODO: 09.10.2022 запуск слушателядоковой панели            МетодСозданияCallBack();            МетодДляСлушательБоковойПанелиAsyncApp();            МетодДоНачалаСинхрониазцииExecutor();///TODO ДО СИНХРОНИАЗЦИИ        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодСитемныйНастройкиЭкран() {        getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD                | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON                | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);        //////todo настрока экрана        getWindow().getDecorView().setSystemUiVisibility(                View.SYSTEM_UI_FLAG_LAYOUT_STABLE                        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION                        | View.SYSTEM_UI_FLAG_FULLSCREEN                        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);        getSupportActionBar().setHomeButtonEnabled(false);        getSupportActionBar().setDisplayHomeAsUpEnabled(false);        getSupportActionBar().setHomeAsUpIndicator(null);    }    @Override    protected void onRestart() {        super.onRestart();        try {            if(preferences!=null){                МетодСитемныйНастройкиЭкран();                // TODO: 26.10.2022                МетодВостановлениеЭкранаПослеПоворота();            }            Log.d(this.getClass().getName(), "onRestart");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодВостановлениеЭкранаПослеПоворота() {        try{            ВостанновленоеСтатусЗапускаAsync = preferences.getBoolean("ВостанновленоеСтатусЗапускаAsync",false);            Log.d(this.getClass().getName(), "ВостанновленоеСтатусЗапускаAsync"+ ВостанновленоеСтатусЗапускаAsync);            ТекстВидBarСинх.setText(preferences.getString("ТекстВидBarСинх",""));            ТекстВидBarСинх.requestLayout();            ТекстВидBarСинх.forceLayout();            ТекстВидBarСинх.refreshDrawableState();            ТекущаяТаблицыИлиГод.setText(preferences.getString("ТекущаяТаблицыИлиГод",""));            ТекущаяТаблицыИлиГод.requestLayout();            ТекущаяТаблицыИлиГод.forceLayout();            ТекущаяТаблицыИлиГод.refreshDrawableState();            progressBar3ГоризонтальныйСинхронизации.setProgress(preferences.getInt("progressBar3ГоризонтальныйСинхронизации",0));            progressBar3ГоризонтальныйСинхронизации.setSecondaryProgress(preferences.getInt("progressBar3ГоризонтальныйСинхронизацииback",0));            progressBarCycle.setProgress(preferences.getInt("progressBar4Cycle",0));            progressBarCycle.setMax(preferences.getInt("progressBar4CycleMAx",0));            progressBar3ГоризонтальныйСинхронизации.requestLayout();            progressBar3ГоризонтальныйСинхронизации.forceLayout();            progressBar3ГоризонтальныйСинхронизации.refreshDrawableState();            progressBarCycle.refreshDrawableState();            // TODO: 26.10.2022            drawerLayoutAsync.forceLayout();            drawerLayoutAsync.refreshDrawableState();        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onStart() {        super.onStart();//////TODO ловим поворот экрана  ДЛЯ СИНХРОНИЗАЦИИ        try{            МетодБоковаяПанельОткрытьЗАкрыть();            МетодВActivityFaveApp_ПредлагаемЗагрузитьНОВОЕПО();            МетодВActivityFaveApp_УстанавливаетПрограммноеОбеспечениеПОТабельныйУчёт();            Log.i(this.getClass().getName(), "ДО  ОТРАБОТАННЙ СИНХРОНИЗАЦИИ ВИЗУАЛЬНОЙ doInBackground asyncTaskГлавныйДляСинхронизации ");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onResume() {        super.onResume();        try{            Log.i(this.getClass().getName(), "onResume  МетодЗапускГлавнойСиинхрониазции ВостанновленоеСтатусЗапускаAsync "+ ВостанновленоеСтатусЗапускаAsync);            if (ВостанновленоеСтатусЗапускаAsync==false) {                if (messengerActivity!=null) {                    ВостанновленоеСтатусЗапускаAsync=true;                }                МетодЗапускГлавнойСиинхрониазции();            }        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onDestroy() {        super.onDestroy();        try{            if (myConnection!=null) {                unbindService(myConnection);            }            // TODO: 12.12.2022  Останавливаем главную службу синъронизации            stopService(new Intent(this,Service_For_Remote_Async.class));            Log.i(this.getClass().getName(), "onDestroy myConnection ");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 26.10.2022 сохраняет данные    protected void onSaveInstanceState(Bundle outState) {        try{            Log.i(this.getClass().getName(), "onSaveInstanceState ");            outState.putBoolean("ВостанновленоеСтатусЗапускаAsync", ВостанновленоеСтатусЗапускаAsync);            outState.putString("ТекстВидBarСинх",  ТекстВидBarСинх.getText().toString());            outState.putString("ТекущаяТаблицыИлиГод",  ТекущаяТаблицыИлиГод.getText().toString());            outState.putInt("progressBar3ГоризонтальныйСинхронизации", progressBar3ГоризонтальныйСинхронизации.getProgress());            outState.putInt("progressBar3ГоризонтальныйСинхронизацииback", progressBar3ГоризонтальныйСинхронизации.getSecondaryProgress());            outState.putInt("progressBar4Cycle",   progressBarCycle.getProgress());            outState.putInt("progressBar4CycleMAx",   progressBarCycle.getMax());            // TODO: 26.10.2022            SharedPreferences.Editor editor = preferences.edit();            editor.putBoolean("ВостанновленоеСтатусЗапускаAsync", ВостанновленоеСтатусЗапускаAsync);            editor.putString("ТекстВидBarСинх",   ТекстВидBarСинх.getText().toString());            editor.putString("ТекущаяТаблицыИлиГод", ТекущаяТаблицыИлиГод.getText().toString());            editor.putInt("progressBar3ГоризонтальныйСинхронизации", progressBar3ГоризонтальныйСинхронизации.getProgress());            editor.putInt("progressBar3ГоризонтальныйСинхронизацииback",  progressBar3ГоризонтальныйСинхронизации.getSecondaryProgress());            editor.putInt("progressBar4Cycle",   progressBarCycle.getProgress());            editor.putInt("progressBar4CycleMAx",   progressBarCycle.getMax());            editor.commit();// This will async            super.onSaveInstanceState(outState);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 26.10.2022 воставливает данные    protected void onRestoreInstanceState(Bundle savedInstanceState) {        super.onRestoreInstanceState(savedInstanceState);        try {            Log.i(this.getClass().getName(), "onRestoreInstanceState ");            МетодСитемныйНастройкиЭкран();            // TODO: 25.10.2022 востанавливаем данных после поворота экрана            МетодВостановлениеЭкранаПослеПоворота();        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    public void onBackPressed()    {        //thats it    }    protected Integer МетодЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму() {        Integer Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации=0;        try{            ContentValues КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил = new ContentValues();            Date Дата = Calendar.getInstance().getTime();            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", new Locale("ru"));//"yyyy-MM-dd HH:mm:ss.SSS"//"yyyy-MM-dd'T'HH:mm:ss'Z'"            dateFormat.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));            Log.d(this.getClass().getName(), " ГЛАВНАЯ ДАТА ПРОГРАММЫ ДСУ-1 : " + dateFormat.format(Дата));            String ДатаДляПоказываетУспешнойСинхрониазцииЧтоПользовательЗаходилВпрограмму = dateFormat.format(Дата);            КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил.put("date_update", ДатаДляПоказываетУспешнойСинхрониазцииЧтоПользовательЗаходилВпрограмму);            Class_GRUD_SQL_Operations class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ= new Class_GRUD_SQL_Operations(getApplicationContext());            class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СамFreeSQLКОд",                    " SELECT id  FROM successlogin  ORDER BY date_update DESC ;");            // TODO: 12.10.2021  Ссылка Менеджер Потоков            PUBLIC_CONTENT  Class_Engine_SQLГдеНаходитьсяМенеджерПотоков =new PUBLIC_CONTENT (getApplicationContext());            SQLiteCursor            Курсор_ПолучаемПубличныйID= (SQLiteCursor) class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                    new GetаFreeData(getApplicationContext()).getfreedata(class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                    Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков                    ,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());            if(Курсор_ПолучаемПубличныйID.getCount()>0){                Курсор_ПолучаемПубличныйID.moveToFirst();                ПубличноеIDПолученныйИзСервлетаДляUUID=         Курсор_ПолучаемПубличныйID.getInt(0);                Log.d(this.getClass().getName(), " ПубличноеIDПолученныйИзСервлетаДляUUID  " + ПубличноеIDПолученныйИзСервлетаДляUUID);            }            Log.d(this.getClass().getName(), " ПубличноеIDПолученныйИзСервлетаДляUUID  " + ПубличноеIDПолученныйИзСервлетаДляUUID);            if ( ПубличноеIDПолученныйИзСервлетаДляUUID>0) {                Class_GRUD_SQL_Operations class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму = new Class_GRUD_SQL_Operations(getApplicationContext());                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("НазваниеОбрабоатываемойТаблицы", "SuccessLogin");                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("Флаг_ЧерезКакоеПолеОбновлением", "id");                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ЗначениеФлагОбновления", ПубличноеIDПолученныйИзСервлетаДляUUID);                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ЗнакФлагОбновления", "=");                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        contentValuesДляSQLBuilder_Для_GRUD_Операций.putAll(КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил);                Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации = (Integer) class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        new UpdateData(getApplicationContext()).updatedata(class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                        class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.contentValuesДляSQLBuilder_Для_GRUD_Операций,                        Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());                Log.d(this.getClass().getName(), " Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации"                        + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);                // TODO: 08.09.2021  resultat                if (Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации > 0) {                    Log.d(getApplicationContext().getClass().getName(), " Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации " + "--"                            + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);/////                } else {                    Log.d(getApplicationContext().getClass().getName(), " NO Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации " + "--"                            + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);/////                }            }        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }        return  Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации;    }    ///TODO вычисляем если такая таблиЦА ВНУТРИ БАЗЫ    protected boolean МетодВЫчисляемВсеТаблицыВнутриКлинета(String ТекущаяТаблицаДляОБменаДанными) {        ////        boolean ЕслиТАкаяТаблица = false;        ////        SQLiteCursor КурсорВсехТаблицВнутри=null;        try{            // TODO: 26.08.2021 НОВЫЙ ВЫЗОВ НОВОГО КЛАСС GRUD - ОПЕРАЦИИ            Class_GRUD_SQL_Operations     class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета=new Class_GRUD_SQL_Operations(getApplicationContext());            ///            class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("НазваниеОбрабоатываемойТаблицы","sqlite_master");            ///////            class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СтолбцыОбработки","name");            //            class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ФорматПосика","type = 'table' ");            ///"_id > ?   AND _id< ?"            //////             /*       class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска1",finalПолученныйUUID);                    ///                    class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска2","Удаленная");                    ///                    class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска3",МЕсяцДляКурсораТабелей);                    //                    class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска4",ГодДляКурсораТабелей);////УсловиеПоискаv4,........УсловиеПоискаv5 .......*/            ////TODO другие поля            ///classGrudSqlOperations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ПоляГрупировки",null);            ////            //class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеГрупировки",null);            ////            // class_grud_sql_operationsПолучениеИмяСистемы. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеСортировки","date_update");            ////            /// class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеЛимита","1");            ////            // TODO: 27.08.2021  ПОЛУЧЕНИЕ ДАННЫХ ОТ КЛАССА GRUD-ОПЕРАЦИИ            КурсорВсехТаблицВнутри=null;            КурсорВсехТаблицВнутри= (SQLiteCursor)  new Class_GRUD_SQL_Operations(getApplicationContext()).                    new GetData(getApplicationContext()).getdata(class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                    Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков                    ,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());            Log.d(this.getClass().getName(), "GetData "  +КурсорВсехТаблицВнутри);    /*            // TODO: 08.09.2021 ____old                /////              КурсорВсехТаблицВнутри=ССылкаНаСозданнуюБазу.rawQuery("SELECT name FROM sqlite_master WHERE type = 'table'",null);*/            // TODO: 08.09.2021 resultat            if(КурсорВсехТаблицВнутри.getCount()>0) {                КурсорВсехТаблицВнутри.moveToFirst();                Log.d(this.getClass().getName(), "  КурсорВсехТаблицВнутри."  +  КурсорВсехТаблицВнутри.getCount());                // TODO: 08.09.2021  цикл                do {                    ////                    if (ТекущаяТаблицаДляОБменаДанными.equals(КурсорВсехТаблицВнутри.getString(0))) {                        Log.d(this.getClass().getName(), "  ТекущаяТаблицаДляОБменаДанными." + ТекущаяТаблицаДляОБменаДанными +                                "  КурсорВсехТаблицВнутри.getString(0)) " + КурсорВсехТаблицВнутри.getString(0));                        ЕслиТАкаяТаблица = true;                        break;                    }                    Log.d(this.getClass().getName(), "  ТекущаяТаблицаДляОБменаДанными." + ТекущаяТаблицаДляОБменаДанными +                            "  КурсорВсехТаблицВнутри.getString(0)) " + КурсорВсехТаблицВнутри.getString(0));                }while(КурсорВсехТаблицВнутри.moveToNext());                ////////                КурсорВсехТаблицВнутри.close();            }else{                Log.d(this.getClass().getName(), "  КурсорВсехТаблицВнутри."  +  КурсорВсехТаблицВнутри.getCount());                //////                ЕслиТАкаяТаблица=false;            }            ///todo публикум название таблицы или цифру его        } catch (Exception e) {            //  Block of code to handle errors            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }////        return ЕслиТАкаяТаблица;    }    void МетодПоказываетЗаблокированЛИПользовательИЛИнетСтатусОтСервера(PUBLIC_CONTENT Class_Engine_SQLГдеНаходитьсяМенеджерПотоков) throws ExecutionException, InterruptedException {        try {            Class_GRUD_SQL_Operations class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ;            // TODO: 28.07.2022 проверка заблокирован ли пользователь или нет            //TODO  ПРОВЕРЯЕМ ТЕКУЩИЙ ПОЛЬЗОВАТЕЛЬ МОЖНО РАБОТАТЬ ИЛИ ОН ЗАБЛОКИРОВАН            ///            class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ=new Class_GRUD_SQL_Operations(getApplicationContext());            // TODO: 26.08.2021 НОВЫЙ ВЫЗОВ НОВОГО КЛАСС GRUD - ОПЕРАЦИИ            ///            class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СамFreeSQLКОд",                    " SELECT locked  FROM chat_users  WHERE _id= '"+ПолученныйПубличныйID+"'  ORDER BY date_update DESC ;");            // TODO: 12.10.2021  Ссылка Менеджер Потоков            Integer ПолученныйСтатусТекущегоПользователя=0;            SQLiteCursor            Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором=null;            ///////            Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором=                    (SQLiteCursor) class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                            new GetаFreeData(getApplicationContext()).getfreedata(class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                                    concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                            Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков,                            Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());            Log.d(this.getClass().getName(), " Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount() "                    +Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount());            if ( Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount()>0 ){                Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.moveToNext();                ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ= Boolean.parseBoolean(Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getString(0))        ;            }            // TODO: 28.07.2022            Log.d(this.getClass().getName(), " ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ "                    +ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ);        } catch (Exception e) {            //  Block of code to handle errors            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    void МетодДоНачалаСинхрониазцииExecutor() {        try{            ДатаДляИзмененияВерсииДанныхНаАндройде = Calendar.getInstance().getTime();            ТекстВидBarСинх.setVisibility(View.VISIBLE);            progressBar3ГоризонтальныйСинхронизации.setSecondaryProgress(2);            progressBar3ГоризонтальныйСинхронизации.getProgressDrawable().setColorFilter(                    Color.parseColor("#D81B60"), android.graphics.PorterDuff.Mode.SRC_IN);            progressBar3ГоризонтальныйСинхронизации.setIndeterminate(true);            progressBar3ГоризонтальныйСинхронизации.setProgress(0);            ТекстВидBarСинх.setText("0 %");           // progressBarCycle.getIndeterminateDrawable().setColorFilter(Color.RED, PorterDuff.Mode.SRC_IN);            Log.d(this.getClass().getName(), " onStartLoading() начало метода  ");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                    " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(),                    Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 02.09.2021  метод визуальной синхронмизации    void МетодЗапускГлавнойСиинхрониазции() {        try{            boolean РазрешениеНаСетьОтПользователя =                    new Class_Find_Setting_User_Network(getApplicationContext())                            .МетодПроветяетКакуюУстановкуВыбралПользовательСети();            Log.w(this.getClass().getName(), " ДО СИНХРОНИАЗЦИИ РазрешениеНаСетьОтПользователя  "                    + РазрешениеНаСетьОтПользователя);            if (РазрешениеНаСетьОтПользователя==true  ) {                //TODO СИНХРОНИАЗЦИЯ ГЛАВНАЯ                // TODO: 26.10.2022                Message msg = Message.obtain();                Bundle bundle = new Bundle();                bundle.putString("СтатусРаботыСлужбыСинхронизации", "ЗапускаемAsyncBackground");                bundle.putString("РежимЗапускаСинхронизации", РежимПерваяЗапускПослеPasswordИлиПовторная);                msg.setData(bundle);                if ( messengerActivity!=null) {                    msg.replyTo = mMessenger;                    messengerActivity.send(msg);                }                Log.w(this.getClass().getName(), "  ПОСЛЕ СИНХРОНИАЗЦИИ РазрешениеНаСетьОтПользователя  "                        + РазрешениеНаСетьОтПользователя);            }else {                Toast.makeText(getApplicationContext(), " Режим интрента не включен !!!! " , Toast.LENGTH_LONG).show();                Log.w(this.getClass().getName(), "РазрешениеНаСетьОтПользователя  "+ РазрешениеНаСетьОтПользователя);            }        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" +                    Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодСозданияCallBack() {        try{            mMessenger = new Messenger(new Handler(Looper.getMainLooper(), new Handler.Callback() {                @Override                public boolean handleMessage(@NonNull Message msg) {                    try {                        Bundle data =msg.getData();                        Integer dataSring=data.getInt("RemoteService");                        String СтатусРаботыСлужбыСинхронизации =data.getString("СтатусРаботыСлужбыСинхронизации");                        Integer МаксимальнеоКоличествоСтрок =data.getInt("МаксималноеКоличествоСтрочекJSON");                        // TODO: 11.10.2022                        switch (СтатусРаботыСлужбыСинхронизации.trim()){                            case "ПроцессеAsyncBackground" :                                Log.w(this.getClass().getName(), "СтатусРаботыСлужбыСинхронизации  "+ СтатусРаботыСлужбыСинхронизации);//TODO СИНХРОНИЗАЦИЯ В ПРОЦЕССЕ........                                // TODO: 11.10.2022  визиализируем ход синхронизации                                МетодВизуализацииСинхронизации(data);                                break;                            case "ФинишВыходИзAsyncBackground" :                                // TODO: 11.10.2022 выход из синхрониазхации конец                                МетодПослеПотокаСинхронизации(МаксимальнеоКоличествоСтрок);//TODO ПОСЛЕ СИНХРОНИЦИИ                                Log.w(this.getClass().getName(), "СтатусРаботыСлужбыСинхронизации  "+ СтатусРаботыСлужбыСинхронизации);                                break;                        }                    } catch (Exception e) {                        e.printStackTrace();                        Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                + Thread.currentThread().getStackTrace()[2].getLineNumber());                        new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                Thread.currentThread().getStackTrace()[2].getLineNumber());                    }                    Log.i(this.getClass().getName(), " public  " +                            "MyWork_Async_Синхронизация_Одноразовая(@NonNull Context context, @NonNull WorkerParameters workerParams) " );                    return true;                }            }));            myConnection =                    new ServiceConnection() {                        public void onServiceConnected(ComponentName className,                                                       IBinder service) {                            try{                                messengerActivity =new Messenger(service);                                Log.d(getApplicationContext().getClass().getName().toString(), "\n"                                        + "onServiceConnected  messengerActivity  " + messengerActivity.getBinder().pingBinder());                                IBinder binder=   messengerActivity.getBinder();                                // TODO: 11.10.2022                                if (binder.isBinderAlive()) {                                    onResume();                                    Log.d(getApplicationContext().getClass().getName().toString(), "\n"                                            + "binder.isBinderAlive()  Запустили "+binder.isBinderAlive());                                }                            } catch (Exception e) {                                e.printStackTrace();                                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                        Thread.currentThread().getStackTrace()[2].getLineNumber());                            }                        }                        public void onServiceDisconnected(ComponentName className) {                            messengerActivity=null;                        }                    };            Intent intent = new Intent(getApplicationContext(), Service_For_Remote_Async.class);            bindService(intent, myConnection, Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_OOM_MANAGEMENT |                    Context.BIND_ADJUST_WITH_ACTIVITY | Context.BIND_IMPORTANT  );        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодВизуализацииСинхронизации(Bundle data) {        try{            // TODO: 15.11.2022  первая часть            Integer МаксималноеКоличествоСтрочекJSON=        data.getInt("МаксималноеКоличествоСтрочекJSON");            if(МаксималноеКоличествоСтрочекJSON!=null){                progressBar3ГоризонтальныйСинхронизации.setMax(МаксималноеКоличествоСтрочекJSON);                progressBar3ГоризонтальныйСинхронизации.setMinHeight(5);                progressBar3ГоризонтальныйСинхронизации.setVisibility(View.VISIBLE);                // TODO: 17.11.2022                progressBarCycle.setMax(100);            }            Integer ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара=                    data.getInt("ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара",0);                Boolean ИндексРЕальнойВствкиИлилОбноывниевConetProver= data.getBoolean("РеальнаяРаботаВставкаОбновиеContProver",false);                Boolean ЧтоДелаемПолучаемДанныеИлиОтправляем= data.getBoolean("ЧтоДелаемПолучаемДанныеИлиОтправляем",false);                if (ИндексРЕальнойВствкиИлилОбноывниевConetProver==true) {                    // TODO: 15.11.2022  реальна вставка в базу                    progressBar3ГоризонтальныйСинхронизации.setIndeterminate(true);                    progressBar3ГоризонтальныйСинхронизации.getIndeterminateDrawable().setColorFilter(Color.GRAY, android.graphics.PorterDuff.Mode.SRC_IN);                   // progressBarCycle.getIndeterminateDrawable().setColorFilter(Color.GRAY, PorterDuff.Mode.SRC_IN);                }else {                    // TODO: 15.11.2022  наполение данными                    if (ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара>0) {                        progressBar3ГоризонтальныйСинхронизации.setIndeterminate(false);                        progressBar3ГоризонтальныйСинхронизации.getProgressDrawable().setColorFilter(  Color.parseColor("#00ACC1"), PorterDuff.Mode.SRC_IN);                     //   progressBarCycle.getIndeterminateDrawable().setColorFilter(Color.RED, PorterDuff.Mode.SRC_IN);                        if (progressBar3ГоризонтальныйСинхронизации.isAttachedToWindow()) {                            if (ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара == 0                                    && preferences.getInt("progressBar3ГоризонтальныйСинхронизации", 0) > 0) {                                progressBar3ГоризонтальныйСинхронизации.setProgress(preferences.getInt("progressBar3ГоризонтальныйСинхронизации", 0), true);                            } else {                                if (  progressBar3ГоризонтальныйСинхронизации.getMax()>ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара) {                                    progressBar3ГоризонтальныйСинхронизации.setProgress(ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара, true);                                    progressBar3ГоризонтальныйСинхронизации.setSecondaryProgress(progressBar3ГоризонтальныйСинхронизации.getProgress() * 2);                                }else{                                    МетодработыССетьюЗагрузкаВыгрузка(ЧтоДелаемПолучаемДанныеИлиОтправляем);                                    ТекстВидBarСинх.startAnimation(animation);                                }                            }                        }                    }else{                        МетодработыССетьюЗагрузкаВыгрузка(ЧтоДелаемПолучаемДанныеИлиОтправляем);                        ТекстВидBarСинх.startAnimation(animation);                    }                }            // TODO: 15.11.2022 вторая часть                        String имяТаблицыОтАндройда_локальноая=    data.getString("имяТаблицыОтАндройда_локальноая");            if (имяТаблицыОтАндройда_локальноая!=null) {                if (ТекущаяТаблицыИлиГод.isAttachedToWindow()) {                    if (ТекущаяТаблицыИлиГод.length()==0 && preferences.getString("ТекущаяТаблицыИлиГод","").length()>0) {                        ТекущаяТаблицыИлиГод.setHint(preferences.getString("ТекущаяТаблицыИлиГод",""));                    } else {                        ТекущаяТаблицыИлиГод.setHint(имяТаблицыОтАндройда_локальноая);                    }                }            }            String ПроцентыВерхнегоПрограссбара=    data.getString("ПроцентыВерхнегоПрограссбара");            if (ПроцентыВерхнегоПрограссбара!=null) {                if (ТекстВидBarСинх.isAttachedToWindow()) {                    if (ПроцентыВерхнегоПрограссбара.equalsIgnoreCase("0 %")                            && preferences.getString("ТекстВидBarСинх","").toString().length()>0) {                        ТекстВидBarСинх.setText(preferences.getString("ТекстВидBarСинх",""));                    } else {                        if (!ПроцентыВерхнегоПрограссбара.isEmpty()) {                            ТекстВидBarСинх.setText(ПроцентыВерхнегоПрограссбара);                            Integer ОбрабоатываемАтблицыПроценты= Integer.valueOf(ПроцентыВерхнегоПрограссбара.replaceAll("[^0-9]", ""));                            progressBarCycle.setProgress(ОбрабоатываемАтблицыПроценты);                        }                    }                }            }            progressBar3ГоризонтальныйСинхронизации.forceLayout();            progressBar3ГоризонтальныйСинхронизации.requestLayout();            progressBarCycle.forceLayout();            progressBarCycle.requestLayout();            ТекстВидBarСинх.forceLayout();            ТекстВидBarСинх.requestLayout();            drawerLayoutAsync.forceLayout();        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодработыССетьюЗагрузкаВыгрузка(Boolean ЧтоДелаемПолучаемДанныеИлиОтправляем) {        progressBar3ГоризонтальныйСинхронизации.setIndeterminate(true);        if (ЧтоДелаемПолучаемДанныеИлиОтправляем ==true) {            progressBar3ГоризонтальныйСинхронизации.getIndeterminateDrawable().setColorFilter(Color.BLACK, PorterDuff.Mode.SRC_IN);            progressBar3ГоризонтальныйСинхронизации.setIndeterminateTintBlendMode(BlendMode.DARKEN);        }else {            progressBar3ГоризонтальныйСинхронизации.getIndeterminateDrawable().setColorFilter(Color.RED, PorterDuff.Mode.SRC_IN);            progressBar3ГоризонтальныйСинхронизации.setIndeterminateTintBlendMode(BlendMode.DARKEN);        }    }    private void МетодБоковаяПанельОткрытьЗАкрыть() {        try {            if (drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                drawerLayoutAsync.closeDrawer(Gravity.LEFT);            }        } catch (Exception e) {            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 03.04.2022    private void МетодДляСлушательБоковойПанелиAsyncApp() {        // TODO: 06.04.2022        try {            imageView_ЗначекAsync.setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    if (navigationViewAsyncApp.isShown()) {                        navigationViewAsyncApp.setVisibility(View.GONE);                        if (drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                            drawerLayoutAsync.closeDrawer(Gravity.LEFT);                        }                    } else {                        navigationViewAsyncApp.setVisibility(View.VISIBLE);                        if (!drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                            drawerLayoutAsync.openDrawer(Gravity.LEFT);                        }                    }                }            });            drawerLayoutAsync.addDrawerListener(new DrawerLayout.SimpleDrawerListener() {                @Override                public void onDrawerOpened(View drawerView) {                    Drawable drawable = getResources().getDrawable(R.mipmap.icon_dsu1_for_asyncapp_close_naviga);///                    imageView_ЗначекAsync.setImageDrawable(drawable);                    navigationViewAsyncApp.setVisibility(View.VISIBLE);                    super.onDrawerOpened(drawerView);                }                @Override                public void onDrawerClosed(View drawerView) {                    Drawable drawable = getResources().getDrawable(R.drawable.icon_dsu1_async_asynprograssbar);///                    imageView_ЗначекAsync.setImageDrawable(drawable);                    navigationViewAsyncApp.setVisibility(View.GONE);                    super.onDrawerClosed(drawerView);                }            });            navigationViewAsyncApp.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {                @Override                public boolean onNavigationItemSelected(@NonNull MenuItem item) {                    switch (item.getItemId()) {                        // TODO: 06.04.2022                        case R.id.one:                            item.setChecked(true);                            Log.w(getPackageName().getClass().getName(), "item.getItemId() Посмотреть ошибки   " + item.getItemId() + "\n");//////////                            try {                                Intent Интент_Меню = new Intent(getApplication(), MainActivity_Errors.class);                                Интент_Меню.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);//////FLAG_ACTIVITY_SINGLE_TOP                                Log.d(this.getClass().getName(), "" +                                        "                     case R.id.ПунктМенюПервый:");                                startActivity(Интент_Меню);                            } catch (Exception e) {                                //  Block of code to handle errors                                e.printStackTrace();                                ///метод запись ошибок в таблицу                                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                        Thread.currentThread().getStackTrace()[2].getLineNumber());                            }                            break;                        case R.id.sedmoy:                            item.setChecked(true);                            try {                                // TODO: 07.10.2022 ЗАПУСК АНАЛИЗА по                                МетодОбновленияПОИзДвухДействийСначалоУдалениеЛюбойВерсииИЗатемСкачиваемЗановоИОбновляемПО();                                Log.w(getPackageName().getClass().getName(), "item.getItemId() МЕНЮ ОБНОВЛЕНИЕ ПО    " + item.getItemId() + "\n");/////////                            } catch (Exception e) {                                e.printStackTrace();                                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                        Thread.currentThread().getStackTrace()[2].getLineNumber());                            }                            break;                        default:                            // TODO: 06.04.2022                            return false;                    }                    if (drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                        drawerLayoutAsync.closeDrawer(Gravity.LEFT);                    }                    return true;                }            });        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }        // TODO: 04.04.2022    }    ///TODO МЕТОД ПОСЛЕ ЗАВЕРШЕНИЯ РАБОТЫ В НИЖНЕМ ПОТОКЕ    public void МетодПослеПотокаСинхронизации(@NonNull Integer МаксимальнеоКоличествоСтрок) throws ExecutionException, InterruptedException {        Log.d(this.getClass().getName(), " КОНЕЦ синхронизация  onStopLoading()  ");        try {            // TODO: 22.11.2022 после синхронизации удаление данных со статусом Удаленой                Intent intentУдалениеСтатусаУдаленияТабеля=new Intent();                intentУдалениеСтатусаУдаленияТабеля.setClass(getApplicationContext(), Service_For_Public.class);                intentУдалениеСтатусаУдаленияТабеля.setAction("ЗапускУдалениеСтатусаУдаленияСтрок");                startService(intentУдалениеСтатусаУдаленияТабеля);            // TODO: 27.10.2022  Удаляем Статус Удаленнаый            ТекстВидBarСинх.setText("100 %");            progressBar3ГоризонтальныйСинхронизации.setSecondaryProgress(2);            progressBar3ГоризонтальныйСинхронизации.getProgressDrawable().setColorFilter(  Color.RED, android.graphics.PorterDuff.Mode.SRC_IN);            progressBar3ГоризонтальныйСинхронизации.setIndeterminate(true);            progressBar3ГоризонтальныйСинхронизации.setMax(МаксимальнеоКоличествоСтрок);            progressBar3ГоризонтальныйСинхронизации.setProgress(МаксимальнеоКоличествоСтрок);            // TODO: 27.10.2022  МетодАнализа Заблокирован или Нет пользователь и запуск Программы            Class_GRUD_SQL_Operations class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ =                    new Class_GRUD_SQL_Operations(getApplicationContext());            МетодПослеСинхрониазцииЗапускаемИОцениваемПользователя(class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ,                    Class_Engine_SQLГдеНаходитьсяМенеджерПотоков);            Log.d(this.getClass().getName(), " ПолученныйПубличныйID  " + ПолученныйПубличныйID);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодПослеСинхрониазцииЗапускаемИОцениваемПользователя(Class_GRUD_SQL_Operations class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ,                                                                        PUBLIC_CONTENT Class_Engine_SQLГдеНаходитьсяМенеджерПотоков)            throws ExecutionException, InterruptedException {        try{            class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СамFreeSQLКОд",                    " SELECT id  FROM successlogin  ORDER BY date_update DESC ;");            // TODO: 12.10.2021  Ссылка Менеджер Потоков            SQLiteCursor Курсор_ПолучаемПубличныйID = null;            Курсор_ПолучаемПубличныйID = (SQLiteCursor) class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                    new GetаFreeData(getApplicationContext()).getfreedata(class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                            concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                    Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков, new CREATE_DATABASE(getApplicationContext()).getССылкаНаСозданнуюБазу());            if (Курсор_ПолучаемПубличныйID.getCount() > 0) {                Курсор_ПолучаемПубличныйID.moveToFirst();                ПолученныйПубличныйID = Курсор_ПолучаемПубличныйID.getInt(0);                Log.d(this.getClass().getName(), " ПолученныйПубличныйID  " + ПолученныйПубличныйID);                МетодПоказываетЗаблокированЛИПользовательИЛИнетСтатусОтСервера(Class_Engine_SQLГдеНаходитьсяМенеджерПотоков);            } else {                ПолученныйПубличныйID = 0;            }            ///TODO УСТАНАВЛИВАЕМ ФЛАГ ПРИ АУНТИФИКАЦИИ И МЯ И ПАРОЛЬ  СТАЫИМ ФЛАГ ОТКЛЮЧИТЬ ОБНОВЛЕНИЕ ПРИ СИНХРОНИЗАЦИИ false по умолчанию проверяем            //TODO и взапивсимости какой статус пришел мы показываем пользователю запуск в програму или перехода на имя и пвароль            Log.w(this.getClass().getName(), " ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ "+ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ);            Intent ИнтентДляЗапускаДляВизуализацииСинхронизации;            if(ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ==false || ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ==null) {                Integer РезультатПоказываетЧтоПользовательУспешноЗАходл =            МетодЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму();                Log.d(this.getClass().getName(), "  РезультатПоказываетЧтоПользовательУспешноЗАходл  " + РезультатПоказываетЧтоПользовательУспешноЗАходл);                String ПолученыйТекущееИмяПользователя = new Class_MODEL_synchronized(getApplicationContext()).МетодПолучениеИмяСистемыДляСменыПользователя(getApplicationContext());                Log.d(this.getClass().getName(), "  ПолученыйТекущееИмяПользователя  " + ПолученыйТекущееИмяПользователя);                textViewТекущийПользовательПРиВизуальнойСинхронизации.setText("пользователь: " + ПолученыйТекущееИмяПользователя.toUpperCase());                ИнтентДляЗапускаДляВизуализацииСинхронизации = new Intent(activity, MainActivity_Face_App.class);                ///TODO   конец ОБНУЛЕНИЯ ПЕРЕМЕННЫХ ПОСЛЕ УСПЕШНОЙ СИНХРНИЗАЦИИ ОБНУЛЯЕМ ВСЕ ПЕРЕМЕННЫЕ КОТОРЫЕ УЧАСТВОВАЛИ В СИНХРОНИЗАЦИИ            }else{                // TODO: 14.10.2021  когда пользователь временно заблокирован                // TODO: 14.10.2021  когда пользователь временно заблокирова                ИнтентДляЗапускаДляВизуализацииСинхронизации= new Intent(activity, MainActivity_Tabels_Users_And_Passwords.class);                Log.e(this.getClass().getName(), " Вы заблокированны обратитесь к Администатору ПО !!! ");                Toast.makeText(getApplicationContext(), "  Вы заблокированны обратитесь к Администатору ПО !!! " , Toast.LENGTH_LONG).show();            }            /////TODO после синхронизации обнуялем*/            ИнтентДляЗапускаДляВизуализацииСинхронизации.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP );            activity.startActivity(ИнтентДляЗапускаДляВизуализацииСинхронизации);            activity.finishAfterTransition();        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    //TODO метод состоит из двух операцию удаление любой уже скаченой версии программы и обновление новой ПО    private void МетодОбновленияПОИзДвухДействийСначалоУдалениеЛюбойВерсииИЗатемСкачиваемЗановоИОбновляемПО() {        try{            boolean РезультатПроВеркиУстановкиПользователяРежимРаботыСетиСтоитЛиЗапускатьСсинхронизацию=                    new  Class_Find_Setting_User_Network(getApplicationContext()).МетодПроветяетКакуюУстановкуВыбралПользовательСети();            if (РезультатПроВеркиУстановкиПользователяРежимРаботыСетиСтоитЛиЗапускатьСсинхронизацию==true) {                final Boolean[] РезультатЕслиСвязьСерверомПередНачаломВизуальнойСинхронизции = {false};                String   ИмяСерверИзХранилица = preferences.getString("ИмяСервера","");                Integer    ПортСерверИзХранилица = preferences.getInt("ИмяПорта",0);                if (ИмяСерверИзХранилица.length()==0 && ПортСерверИзХранилица==0) {                    РезультатЕслиСвязьСерверомПередНачаломВизуальнойСинхронизции[0]  =                            new Class_Connections_Server(getApplicationContext()).МетодПингаСервераРаботаетИлиНет(getApplicationContext());                } else {                    Log.d(this.getClass().getName(), "ИмяСерверИзХранилица "+ИмяСерверИзХранилица + " ПортСерверИзХранилица "+ПортСерверИзХранилица);                }                if (РезультатЕслиСвязьСерверомПередНачаломВизуальнойСинхронизции[0] == true) {                    МЕтодЗапускСЛУЖБЫОбновленияПО(true);                } else {                    activity.runOnUiThread(new Runnable() {                        @Override                        public void run() {                            Toast toast = Toast.makeText(getApplicationContext(), "Нет связи c Cервер !!!", Toast.LENGTH_LONG);                            toast.setGravity(Gravity.BOTTOM, 0, 40);                            toast.show();                            Log.d(this.getClass().getName(), "  НЕТ СВЯЗИ С СЕРВЕРОМ  МетодВActivityFaveApp_УстанавливаетПрограммноеОбеспечениеПОТабельныйУчёт();  ");                        }                    });                }            }        } catch (Exception e) {            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 20.12.2021 метод запуска повторного уведомлениия  и загрузки ПО ОБновлени файла    private void МЕтодЗапускСЛУЖБЫОбновленияПО( Boolean СтатусЗапускаОбновление) {        try{            //////////////////////TODO SERVICE            String[] permissions = new String[]{                    Manifest.permission.INTERNET,                    Manifest.permission.READ_PHONE_STATE,                    Manifest.permission.READ_EXTERNAL_STORAGE,                    Manifest.permission.WRITE_EXTERNAL_STORAGE,                    Manifest.permission.VIBRATE,                    Manifest.permission.RECORD_AUDIO,                    Manifest.permission.RECORD_AUDIO,                    Manifest.permission.REQUEST_INSTALL_PACKAGES,                    Manifest.permission.ACCESS_FINE_LOCATION,                    Manifest.permission.ACCESS_LOCATION_EXTRA_COMMANDS,                    Manifest.permission.MANAGE_EXTERNAL_STORAGE,                    Manifest.permission.ACCESS_BACKGROUND_LOCATION,                    Manifest.permission.ACCESS_NETWORK_STATE,                    Manifest.permission.ACCESS_MEDIA_LOCATION,                    Manifest.permission.INSTALL_PACKAGES,                    Manifest.permission.WRITE_SETTINGS,                    Manifest.permission.WRITE_SECURE_SETTINGS            };            ActivityCompat.requestPermissions(activity, permissions, 1);            new Class_Generation_SendBroadcastReceiver_And_Firebase_OneSignal(getApplicationContext()).                    МетодЗапускаУведомленияОбновленияПО(СтатусЗапускаОбновление);            Log.w(getPackageName().getClass().getName(), " new Class_Generation_SendBroadcastReceiver_And_Firebase_OneSignal(getApplicationContext()).\n" +                    "                                    МетодПовторногоЗапускаВсехWorkManagerДляОбновленияПО() " );        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодВActivityFaveApp_ПредлагаемЗагрузитьНОВОЕПО() {        try {            Log.d(this.getClass().getName(), "  МетодЗапускПослеНажатияНАНовойФормеНАКнопкуУстановитьПослеУспешнойЗагрузкиНовогоПОТабельныйУчётПоказываемЕгоПользователю");            // TODO: 25.03.2022 Создание Локального БродКстаера            LocalBroadcastManager localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт;            BroadcastReceiver broadcastReceiverУстановкаПО;            localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт = LocalBroadcastManager.getInstance(getApplicationContext());            broadcastReceiverУстановкаПО = new BroadcastReceiver() {                @Override                public void onReceive(Context context, Intent intent) {                    Log.d(this.getClass().getName(), " localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт  intent " + intent);                    Bundle bundle = intent.getExtras();                    Log.d(this.getClass().getName(), " localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт  bundle " + bundle);                    Integer СервернаяВерсияПОРазмерФайла = bundle.getInt("СервернаяВерсияПОВнутри", 0);                    Log.d(this.getClass().getName(), " СервернаяВерсияПОРазмерФайла " + СервернаяВерсияПОРазмерФайла);                    if (СервернаяВерсияПОРазмерФайла > 0) {                        МетодПредлагаемЗаргузитьНовыюВерсиюПО(СервернаяВерсияПОРазмерФайла);                    }                    Log.d(this.getClass().getName(), " localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт  intent " + intent);                }            };            // TODO: 25.03.2022 установливам настройки Фильмо к Локальному БродКсстеру            IntentFilter intentFilterУстановка = new IntentFilter();            // TODO: 25.03.2022            intentFilterУстановка.addAction("AfterDownloadPO");            localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт.registerReceiver(broadcastReceiverУстановкаПО, intentFilterУстановка);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодПредлагаемЗаргузитьНовыюВерсиюПО(@NonNull Integer СервернаяВерсияПОВнутри) {        try {            File ФайлыДляОбновлениеВычисляемНомерВерсииПО = null;            final PackageManager pm =  getPackageManager();            String apkName = "update_dsu1.apk";            String fullPath = Environment.getExternalStorageDirectory() + "/" + apkName;            if (Build.VERSION.SDK_INT >= 30) {                fullPath = Environment.getExternalStorageState() + "/" + apkName;            } else {                fullPath = Environment.getExternalStorageDirectory() + "/" + apkName;            }            fullPath = Environment.DIRECTORY_DOWNLOADS + "/" + apkName;            PackageInfo info = pm.getPackageArchiveInfo(fullPath, 0);            if (info != null) {                Log.d(this.getClass().getName(), "VersionCode : " + info.versionCode + ", VersionName : " + info.versionName);                СервернаяВерсияПОВнутри = info.versionCode;            }            // TODO: 02.04.2022            final Object ТекущаяВерсияПрограммы = BuildConfig.VERSION_CODE;            Integer ЛокальнаяВерсияПОСравнение = Integer.parseInt(ТекущаяВерсияПрограммы.toString());            AlertDialog alertDialog = new MaterialAlertDialogBuilder(this)///       final AlertDialog alertDialog =new AlertDialog.Builder( MainActivity_Face_App.КонтекстFaceApp)                    .setTitle("Загрущик")                    .setMessage("Пришло Обновление,"                            + "\n" + "Союз-Автодор ПО ,"                            + "\n" + "новая версия. " + СервернаяВерсияПОВнутри + ","//TODO old          + "\n" + "локальная версия. " + ЛокальнаяВерсияПОСравнение + ","                            + "\n")                    .setPositiveButton("Загрузить", null)                    .setNegativeButton("Позже", null)                    .setIcon(R.drawable.icon_dsu1_update_success)                    .show();/////////кнопка            final Button MessageBoxUpdateОбновитьПО = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);            Integer finalСервернаяВерсияПОВнутри = СервернаяВерсияПОВнутри;            MessageBoxUpdateОбновитьПО.setOnClickListener(new View.OnClickListener() {                ///MessageBoxUpdate метод CLICK для DIALOBOX                @Override                public void onClick(View v) {                    Log.d(this.getClass().getName(), "Установка Обновления .APK СЛУЖБА");                    String ФинальныйПутьДляЗагрузкиФайлаОбновения = null;                    ////                    Log.d(this.getClass().getName(), " СервернаяВерсияПОВнутри" + finalСервернаяВерсияПОВнутри);                    Vibrator v2 = (Vibrator) getApplicationContext().getSystemService(Context.VIBRATOR_SERVICE);                    v2.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE));                    //TODO ПЕРЕД СОЗДАНИЕМ НОВОГО СООБЕЩНИЯ ОБНУЛЯЕМ ПРДЫДУЩЕЕ                    Class_Update_Download_File_APK_From_SERVER class_update_download_file_apk_from_server=new Class_Update_Download_File_APK_From_SERVER(getApplicationContext(),null);                    class_update_download_file_apk_from_server.МетодУдалениеИнформационогоТекстовогоФайлаJSONДляПО();                    Log.i(getApplicationContext().getClass().getName(), " ЗАПУСКАЕМ МетодУдалениеИнформационогоТекстовогоФайлаJSONДляПО();  ");                    class_update_download_file_apk_from_server.МетодУдалениеСамогоФайлаПрограммыПОТальныйУчётПО_APK();                    Log.i(getApplicationContext().getClass().getName(), " ЗАПУСКАЕМ МетодУдалениеСамогоФайлаПрограммыПОТальныйУчётПО_APK();  ");                    try {                        class_update_download_file_apk_from_server.МетодНачалаЗапускаОбновленияПО(finalСервернаяВерсияПОВнутри);                    } catch (ExecutionException e) {                        e.printStackTrace();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    Log.i(getApplicationContext().getClass().getName(), " УЖЕ ЗАГРУзили ПО ПОЛЬЗОВАТЕЛЬ НАЖАЛ НА КОНОПКУ ЗАГУРДИТЬ   " +                            "Service_Notifocations_Для_Чата (intent.getAction()   СЛУЖБА" + finalСервернаяВерсияПОВнутри + " время запуска  " + new Date());                    alertDialog.dismiss();                    alertDialog.cancel();                }            });            final Button MessageBoxUpdateНеуСтанавливатьПО = alertDialog.getButton(AlertDialog.BUTTON_NEGATIVE);            MessageBoxUpdateНеуСтанавливатьПО.setOnClickListener(new View.OnClickListener() {                ///MessageBoxUpdate метод CLICK для DIALOBOX                @Override                public void onClick(View v) {                    //удаляем с экрана Диалог                    alertDialog.dismiss();                    Log.d(this.getClass().getName(), "MessageBoxUpdateНеуСтанавливатьПО  ОТМЕНА УСТАНВОКИ НОВГО ПО   dismiss ");                    alertDialog.cancel();                    // activity.finishAndRemoveTask(); //// ((Activity) MainActivity_Face_App.КонтекстFaceApp).finish();                }            });        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 28.12.2021  метоД КОТРЙ ПОКАЗЫВАЕМ ЧТО ЗАГРУЗИЛОСЬ НОВОЕ ПО ТАБЕЛЬНЫЙ УЧЁТ СКАЧАЛОСЬ ИНАДО ПРИНЯТЬ РЕШЕНИЕ ОБНОВЛЕНМ ИЛИ НЕТ    private void МетодВActivityFaveApp_УстанавливаетПрограммноеОбеспечениеПОТабельныйУчёт() {        try {            Log.d(this.getClass().getName(), "  МетодЗапускПослеНажатияНАНовойФормеНАКнопкуУстановитьПослеУспешнойЗагрузкиНовогоПОТабельныйУчётПоказываемЕгоПользователю");            // TODO: 25.03.2022 Создание Локального БродКстаера            LocalBroadcastManager localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт;            BroadcastReceiver broadcastReceiverУстановкаПО;            localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт = LocalBroadcastManager.getInstance(getApplicationContext());            broadcastReceiverУстановкаПО = new BroadcastReceiver() {                @Override                public void onReceive(Context context, Intent intent) {                    Log.d(this.getClass().getName(), " localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт  intent " + intent);                    Bundle bundle = intent.getExtras();                    Log.d(this.getClass().getName(), " localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт  bundle " + bundle);                    Integer ЗагрузиласьНоваяВерисяПОПровремяем = bundle.getInt("СервернаяВерсияПОВнутри", 0);                    File ЗагрузкиФайлаОбновенияПОДополнительный = (File) bundle.getSerializable("СервернаяВерсияПОCамФайлДляПередачи");                    Long СервернаяВерсияПОРазмерФайла = bundle.getLong("СервернаяВерсияПОРазмерФайла", 0l);                    Log.d(this.getClass().getName(), " ЗагрузиласьНоваяВерисяПОПровремяем  intent "                            + ЗагрузиласьНоваяВерисяПОПровремяем + "ЗагрузкиФайлаОбновенияПОДополнительный " + ЗагрузкиФайлаОбновенияПОДополнительный                            + " СервернаяВерсияПОРазмерФайла " + СервернаяВерсияПОРазмерФайла);                    if (СервернаяВерсияПОРазмерФайла > 0) {                        getApplicationContext().getMainExecutor().execute(()->{                            МетодУстановкиНовойВерсииПОТабельныйУчётПоднимаетЕгоНаActrivity(ЗагрузиласьНоваяВерисяПОПровремяем, ЗагрузкиФайлаОбновенияПОДополнительный);                            Log.d(this.getClass().getName(), " localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт  intent " + intent);                        });                    }                    Log.d(this.getClass().getName(), " localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт  intent " + intent);                }            };            // TODO: 25.03.2022 установливам настройки Фильмо к Локальному БродКсстеру            IntentFilter intentFilterУстановка = new IntentFilter();            intentFilterУстановка.addAction("CompletePO");            localBroadcastManagerДляФинальнойУстановкиПОТабельныйУчёт.registerReceiver(broadcastReceiverУстановкаПО, intentFilterУстановка);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    //todo Финальный метод в ОБНОВЛЕНИИ ПО УСТАВНКА НЕПОСРЕДСВЕННО ФАЙЛА НА АКТИВТИ ПОЛЬЗОВАТЛЕМ    @UiThread    private void МетодУстановкиНовойВерсииПОТабельныйУчётПоднимаетЕгоНаActrivity(@NonNull Integer СервернаяВерсияПОВнутри,                                                                                 @NonNull File ЗагрузкиФайлаОбновенияПОДополнительный) {        try {            File ФайлыДляОбновлениеВычисляемНомерВерсииПО = null;            final PackageManager pm = getPackageManager();            String apkName = "update_dsu1.apk";            String fullPath = Environment.getExternalStorageDirectory() + "/" + apkName;            if (Build.VERSION.SDK_INT >= 30) {                fullPath = Environment.getExternalStorageState() + "/" + apkName;            } else {                fullPath = Environment.getExternalStorageDirectory() + "/" + apkName;            }            fullPath = Environment.DIRECTORY_DOWNLOADS + "/" + apkName;            PackageInfo info = pm.getPackageArchiveInfo(fullPath, 0);            if (info != null) {                Log.d(this.getClass().getName(), "VersionCode : " + info.versionCode + ", VersionName : " + info.versionName);                СервернаяВерсияПОВнутри = info.versionCode;            }            final Object ТекущаяВерсияПрограммы = BuildConfig.VERSION_CODE;            Integer ЛокальнаяВерсияПОСравнение = Integer.parseInt(ТекущаяВерсияПрограммы.toString());            AlertDialog alertDialog = new MaterialAlertDialogBuilder(this)///       final AlertDialog alertDialog =new AlertDialog.Builder( MainActivity_Face_App.КонтекстFaceApp)                    .setTitle("Установщик")                    .setMessage("Пришло Обновление,"                            + "\n" + "Союз-Автодор ПО ,"                            + "\n" + "новая версия. " + СервернаяВерсияПОВнутри + ","//TODO old          + "\n" + "локальная версия. " + ЛокальнаяВерсияПОСравнение + ","                            + "\n")                    .setPositiveButton("Установить", null)                    .setNegativeButton("Позже", null)                    .setIcon(R.drawable.icon_dsu1_updates_po_success)                    .show();/////////кнопка            final Button MessageBoxUpdateОбновитьПО = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);            MessageBoxUpdateОбновитьПО.setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    Log.d(this.getClass().getName(), "Установка Обновления .APK СЛУЖБА");                    String ФинальныйПутьДляЗагрузкиФайлаОбновения = null;                    if (Build.VERSION.SDK_INT >= 30) {                        ФинальныйПутьДляЗагрузкиФайлаОбновения = getApplicationContext().getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS) + "/";  //null                    } else {                        ФинальныйПутьДляЗагрузкиФайлаОбновения = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS) + "/";                    }                    Log.d(this.getClass().getName(), "Установка Обновления .APK СЛУЖБА  ФинальныйПутьДляЗагрузкиФайлаОбновения " + ФинальныйПутьДляЗагрузкиФайлаОбновения);                    String НазваниеФайлаОбновления = "update_dsu1.apk";                    ФинальныйПутьДляЗагрузкиФайлаОбновения += НазваниеФайлаОбновления;                    Uri URIПутиДляЗагрузкиФайловЧерезПровайдер = FileProvider.getUriForFile(getApplicationContext(),                            getApplicationContext().getPackageName() + ".provider",                            ЗагрузкиФайлаОбновенияПОДополнительный);                    Log.d(this.getClass().getName(), "Установка ЗагрузкиФайлаОбновенияПОДополнительный  " + ЗагрузкиФайлаОбновенияПОДополнительный);                    Intent intentОбновлениеПО = new Intent(Intent.ACTION_INSTALL_PACKAGE);                    intentОбновлениеПО.setDataAndType(URIПутиДляЗагрузкиФайловЧерезПровайдер, "application/vnd.android.package-archive");                    intentОбновлениеПО.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION |                            Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION                            | Intent.FLAG_ACTIVITY_NEW_TASK);                    intentОбновлениеПО.putExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, true);                    intentОбновлениеПО.putExtra(Intent.EXTRA_STREAM, URIПутиДляЗагрузкиФайловЧерезПровайдер);                    PackageManager МеханизмПроверкиЗапуститьсяНашИнтентИлиНЕт = activity.getPackageManager();                    if (intentОбновлениеПО.resolveActivity(МеханизмПроверкиЗапуститьсяНашИнтентИлиНЕт) != null) {                        //////todo запуск установкика .apk                        ///     context. startActivity(intent); ////   ((Activity) MainActivity_Face_App.КонтекстFaceApp). startActivity(intent);//  MainActivity_Face_App.КонтекстFaceApp. startActivity(intent);                        Log.d(this.getClass().getName(), " СЛУЖБА УСТАНОВКА... ОБНОВЛЕНИЯ НА ТЕЛЕФОН (.APK файл)  МеханизмПроверкиЗапуститьсяНашИнтентИлиНЕт "                                + МеханизмПроверкиЗапуститьсяНашИнтентИлиНЕт);                        ////TODO непосрдствено сам запуск новго .apk файла                        startActivity(intentОбновлениеПО);                        finishAndRemoveTask(); //// ((Activity) MainActivity_Face_App.КонтекстFaceApp).finish();                        Log.w(this.getClass().getName(), " ура !!!! УРА !!!!  уСПЕШНАЫЙ ЗАПУСК СКАЧЕННОГО ОБНОВЛЕНЕИ ПО " +                                "МетодУстановкиНовойВерсииПОТабельныйУчётПоднимаетЕгоНаActrivity  ");                    } else {                        ///////TODO ОСТАНАВЛИВАЕМ СЛУЖБУ ЧЕРЕЗ 20 СЕКУНД                        Log.d(this.getClass().getName(), "Ошибка файл .APK не устнаовлен ОШИБКА СЛУЖБА ОБНОВЛЕНИЯ ...  "                                + new Date() + " МеханизмПроверкиЗапуститьсяНашИнтентИлиНЕт " + МеханизмПроверкиЗапуститьсяНашИнтентИлиНЕт);                    }                }            });            final Button MessageBoxUpdateНеуСтанавливатьПО = alertDialog.getButton(AlertDialog.BUTTON_NEGATIVE);            MessageBoxUpdateНеуСтанавливатьПО.setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    //удаляем с экрана Диалог                    alertDialog.dismiss();                    Log.d(this.getClass().getName(), "MessageBoxUpdateНеуСтанавливатьПО  ОТМЕНА УСТАНВОКИ НОВГО ПО   dismiss ");                    alertDialog.cancel();                    // activity.finishAndRemoveTask(); //// ((Activity) MainActivity_Face_App.КонтекстFaceApp).finish();                }            });        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }}//////ТУТ БУДЕТ ЗАПИСЫВАТЬСЯ УСПЕШНОЕ ОБНЛВДЕНИ И ВСТАВКИ ДАННЫХ НА СЕРВЕРЕ ДЛЯ КЛИЕНТА